# 环境

- Ubuntu Server 最新LTS

- msql

  > sudo apt-get install mysql-server mysql-client
  >
  > sudo apt-get install libmysqlclient-dev
  >
  > 需要的头文件出现在/usr/include/mysql中

  - 配置mysql的用户名root密码

    ```bash
    sudo mysql_secure_installation
    ```

  - 修改远程连接的配置文件

    ```bash
    sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 
    # 注释掉 bind-address           = 127.0.0.1
    ```

  - 新建用户并授权

    ```mysql
    create user 'chuancey'@'%' identified by 'Zhangsan@elem123';
    
    grant all on *.* to 'chuancey'@'%';
    ```

    

  - 查看所有的开放端口

    ```bash
    netstat -aptn
    ```

  - 查看mysql是否运行

    ```bash
    sudo netstat -tap | grep mysql
    ```

    

# 用到的工具

C# 连接数据库用到官方的库`MySql.Data.dll`



在用xshell操作vim时用ctrl+s会导致xshell假死，按ctrl+q退出假死状态

# 下一步的规划

- c语言执行sql命令

  C语言交互数据库要用到`<mysql/mysql.h>`头文件，编译时需要加参数`-lmysqlclient`

  与MySQL交互时，应用程序应使用该一般性原则：

  1. 通过调用mysql_library_init()，初始化MySQL库。库可以是mysqlclient  C客户端库，或mysqld嵌入式服务器库，具体情况取决于应用程序是否与“-libmysqlclient”或“-libmysqld”标志链接。

  2. 通过调用mysql_init()初始化连接处理程序，并通过调用mysql_real_connect()连接到服务器。

  3. 发出SQL语句并处理其结果。

     1. 通过调用mysql_store_result()，一次性地检索整个结果集。该函数能从服务器获得查询返回的所有行，并将它们保存在客户端
     2. 第二种方式是针对客户端的，通过调用mysql_use_result()，对“按行”结果集检索进行初始化处理。该函数能初始化检索结果，但不能从服务器获得任何实际行。

     两种情况下，均能通过调用mysql_fetch_row()访问行。通过mysql_store_result()，mysql_fetch_row()能够访问以前从服务器获得的行。通过mysql_use_result()，mysql_fetch_row()能够实际地检索来自服务器的行。通过调用mysql_fetch_lengths()，能获得关于各行中数据大小的信息。

     **完成结果集操作后，请调用mysql_free_result()释放结果集使用的内存。**

  4. 通过调用mysql_close()，关闭与MySQL服务器的连接。

  5. 通过调用mysql_library_end()，结束MySQL库的使用。

- 两者交互用json传输

  > 发送方与接受发传输数据：
  >
  > 序列化------->网络传输--------->反序列化
  >
  > json序列化是指，将有key-value结构的数据类型（比如结构体、map、切片）序列化成json字符串的操作。
  >
  > json反序列化的过程是：将json字符串转换成相应的数据类型
  
  服务器端采用cjson的库操作json字符串





# 线程池的实现



一般来说实现一个线程池主要包括以下几个组成部分：

1. **线程管理器：**用于创建并管理线程池。
2. **工作线程：**线程池中实际执行任务的线程。在初始化线程时会预先创建好固定数目的线程在池中，这些初始化的线程一般处于空闲状态，一般不占用CPU，占用较小的内存空间。
3. **任务接口：**每个任务必须实现的接口，当线程池的任务队列中有可执行任务时，被空闲的工作线程调去执行（线程的闲与忙是通过互斥量实现的，跟前面文章中的设置标志位差不多），把任务抽象出来形成接口，可以做到线程池与具体的任务无关。
4. **任务队列：**用来存放没有处理的任务，提供一种缓冲机制，实现这种结构有好几种方法，常用的是队列，主要运用先进先出原理，另外一种是链表之类的数据结构，可以动态的为它分配内存空间，应用中比较灵活，下文中就是用到的链表。





























