# 环境

- Ubuntu Server 最新LTS

- msql

  > sudo apt-get install mysql-server mysql-client
  >
  > sudo apt-get install libmysqlclient-dev
  >
  > 需要的头文件出现在/usr/include/mysql中

  - 配置mysql的用户名root密码

    ```bash
    sudo mysql_secure_installation
    ```

  - 修改远程连接的配置文件

    ```bash
    sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 
    # 注释掉 bind-address           = 127.0.0.1
    ```

  - 新建用户并授权

    ```mysql
    create user 'chuancey'@'%' identified by 'Zhangsan@elem123';
    
    grant all on *.* to 'chuancey'@'%';
    ```

    

  - 查看所有的开放端口

    ```bash
    netstat -aptn
    ```

  - 查看mysql是否运行

    ```bash
    sudo netstat -tap | grep mysql
    ```


# 用到的工具

C# 连接数据库用到官方的库`MySql.Data.dll`



在用xshell操作vim时用ctrl+s会导致xshell假死，按ctrl+q退出假死状态

# 下一步的规划

通过wireshark抓包发现百度网盘的下载采用的是http协议，实现http协议的方式写web服务器



web服务器用epoll+线程池实现。：：学习使用IO复用函数：select、poll、epoll

从main函数开始一点点实现！

- 单例化
- 系统日志的使用
- 命令行解析：线程数、后台运行、杀死后台、帮助文档

- 要完成http请求的解析！



http何时用到json解析？

session和cookie

http上传下载文件：https://www.cnblogs.com/liferecord/p/4866219.html



- c语言执行sql命令

  C语言交互数据库要用到`<mysql/mysql.h>`头文件，编译时需要加参数`-lmysqlclient`

  与MySQL交互时，应用程序应使用该一般性原则：

  1. 通过调用mysql_library_init()，初始化MySQL库。库可以是mysqlclient  C客户端库，或mysqld嵌入式服务器库，具体情况取决于应用程序是否与“-libmysqlclient”或“-libmysqld”标志链接。

  2. 通过调用mysql_init()初始化连接处理程序，并通过调用mysql_real_connect()连接到服务器。

  3. 发出SQL语句并处理其结果。

     1. 通过调用mysql_store_result()，一次性地检索整个结果集。该函数能从服务器获得查询返回的所有行，并将它们保存在客户端
     2. 第二种方式是针对客户端的，通过调用mysql_use_result()，对“按行”结果集检索进行初始化处理。该函数能初始化检索结果，但不能从服务器获得任何实际行。

     两种情况下，均能通过调用mysql_fetch_row()访问行。通过mysql_store_result()，mysql_fetch_row()能够访问以前从服务器获得的行。通过mysql_use_result()，mysql_fetch_row()能够实际地检索来自服务器的行。通过调用mysql_fetch_lengths()，能获得关于各行中数据大小的信息。

     **完成结果集操作后，请调用mysql_free_result()释放结果集使用的内存。**

  4. 通过调用mysql_close()，关闭与MySQL服务器的连接。

  5. 通过调用mysql_library_end()，结束MySQL库的使用。

- 两者交互用json传输

  > 发送方与接受发传输数据：
  >
  > 序列化------->网络传输--------->反序列化
  >
  > json序列化是指，将有key-value结构的数据类型（比如结构体、map、切片）序列化成json字符串的操作。
  >
  > json反序列化的过程是：将json字符串转换成相应的数据类型
  
  服务器端采用cjson的库操作json字符串

# 笔记

- 线程池中的线程数量应该和CPU数量差不多

- 线程池的实现

  一般来说实现一个线程池主要包括以下几个组成部分：

  1. **线程管理器：**用于创建并管理线程池。
  2. **工作线程：**线程池中实际执行任务的线程。在初始化线程时会预先创建好固定数目的线程在池中，这些初始化的线程一般处于空闲状态，一般不占用CPU，占用较小的内存空间。
  3. **任务接口：**每个任务必须实现的接口，当线程池的任务队列中有可执行任务时，被空闲的工作线程调去执行（线程的闲与忙是通过互斥量实现的，跟前面文章中的设置标志位差不多），把任务抽象出来形成接口，可以做到线程池与具体的任务无关。
  4. **任务队列：**用来存放没有处理的任务，提供一种缓冲机制，实现这种结构有好几种方法，常用的是队列，主要运用先进先出原理，另外一种是链表之类的数据结构，可以动态的为它分配内存空间，应用中比较灵活，下文中就是用到的链表。

- HTTP是无状态的、无连接的

  - 标准的http协议指的是不包括cookies, session，application的http协议，他们都不属于标准协议，虽然各种网络应用提供商，实现语言、web容器等，都默认支持它

    - 无状态的官方解释
      1. 协议对于事务处理没有记忆能力【事物处理】【记忆能力】
      2. 对同一个url请求没有上下文关系【上下文关系】
      3. 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况【无直接联系】【受直接影响】
      4. 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器【状态】

  - 无连接：

    - 每一个访问都是无连接，服务器挨个处理访问队列里的访问，处理完一个就关闭连接，这事儿就完了，然后处理下一个新的
    - 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接




  - HTTP请求头中的Content-Length
    - Content-Length用以指定body的大小
    - Content-Length不一定提前知道，可以分块传输，加上一个字段：Transfer-Encoding:chunked（接下来的body我要一块一块的传，每一块开始是这一块的大小，等我传到大小为0的块时，就没了）

  

- 三个IO多路复用函数的区别：
  - select最多只能支持1024个描述符，因为它是使用含有1024比特的long型数组的结构fd_set来“存放”监听的文件描述符，虽然可以在内核中修改此参数但是非常不方便。



- 解决每次git push都要输入账号密码

  - 原因是提交绑定的是https方式，需要改成ssh方式

    ```bash
    git remote rm origin
    git remote add origin ssh地址
    ```

- Ubuntu 安装软件时出现依赖问题：

  ```bash
  sudo apt install aptitude
  sudo aptitude install xxxx
  ```

- vimplus安装后可能还需要重新编译安装Youcompleteme插件，并安装clangd编译器并在这之前安装常见的编译工具

- 换电脑后同步仓库

  ```bash
  git init
  git remote add origin 项目地址
  git fetch origin
  git push --set-upstream origin master
  ```

- 使用syslog后，响应的日志可以通过命令查看

  ```bash
  cat /var/log/syslog | grep webServer
  ```

  

- 有关JSON

  > json相较于xml，标记数量更少，应用更广泛

  - 两种格式

    ```json
    {
        key1:value1,
        key2:value2,
        ...
    }
    ---------------------------------------------------------------------------------------------------
    [
        {
            key1:value1,
            key2:value2 
        },
        {
             key3:value3,
             key4:value4   
        }
    ]
    ```

  - 相关名词

    - json字符串：var jsonStr = "{StudentID:'100',Name:'tmac',Hometown:'usa'}";
    - json对象：var jsonObj = { StudentID: "100", Name: "tmac", Hometown: "usa" };

- http协议中body的几种类型

  - form-data：表单类型

    ```html
    Content-Type: multipart/form-data;
    
    Content-Disposition: form-data; name="123"
    
    456
    ```

  - application/x-www-form-urlencoded：以键值对的数据格式提交,以&分隔

    ```html
    Content-Type: application/x-www-form-urlencoded
    
    x=y&sssssss=sdfdfdf
    ```

  - raw：

    > 选择text，则请求头是： text/plain
    > 选择javascript，则请求头是： application/javascript
    > 选择json，则请求头是： application/json (如果想以json格式传参，就用raw+json就行了)
    > 选择html，则请求头是： text/html
    > 选择application/xml，则请求头是： application/xml

    ```bash
    # 此时不会出现 Content-Type字段
    ```

  - binary：只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。(一般用的不多)

    > 相当于Content-Type:application/octet-stream



- postman中Params和Body的区别
  - Params 它会将参数放入url的?后面提交到后台（带到请求的接口链接里）
  - Body是放在请求体里面



- cookie和session
  - **cookie是由服务器产生的，存放在客户端的一系列键值对组成的文本信息，他的大小最多只有4K**
  - 会话cookie和持久cookie：
    - 会话cookie是指cookie的生命期是在浏览器会话期间，关闭浏览器的话，cookie就消失了
    - 持久cookie是指cookie存放在硬盘上并且他的生命长端是在服务端设置
  - cookie在服务端无法设置失效，只能在浏览器设置失效
  - Session原理
    - 服务器端对session是以map形式管理的（散列表）
    - 服务器生成32位的JSESSIONID，将JSESSIONID作为key放在cookie里面，JSESSIONID 的值作为value发送给客户端
    - 客户端保存session信息，下次请求服务器时会携带JSESSIONID值
    - 服务端拿到JESSIONID的值会去session列表查找对应的value









































